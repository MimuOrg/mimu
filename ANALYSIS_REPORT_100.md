# Mimu: детальный аудит (~100 недочётов и ошибок)

## Критические (блокируют сборку/запуск)

1. **Сервер: `ApiError::forbidden` не определён** — в `server/src/web/error.rs` нет метода `forbidden`, тогда как он вызывается в `messages/handlers.rs`, `chats/handlers.rs`, `media/handlers.rs` (16 мест). Проект на Rust не соберётся без `pub fn forbidden(message: impl Into<String>) -> Self { ... }` с `StatusCode::FORBIDDEN` и `code: "forbidden"`.

2. **Клиент: `ServerConfig.baseUrl` отсутствует** — в `auth_service.dart` и `crypto_auth_service.dart` используется `ServerConfig.baseUrl`, в `ServerConfig` есть только `getApiBaseUrl()`. Либо падение в рантайме, либо нерабочий вход. Добавить `static String get baseUrl => getApiBaseUrl();` или заменить вызовы.

3. **Сервер: маршруты crypto-auth не в роутере** — в `router.rs` нет `POST /auth/challenge`, `POST /auth/verify`, `POST /auth/register-crypto`. Обработчики есть в `crypto_handlers.rs`, но не подключены. Crypto-авторизация с клиента не работает.

4. **Клиент: wordlists не в assets** — `bip39_wordlists.dart` грузит `assets/wordlists/english.txt` и `russian.txt` через `rootBundle`. В `pubspec.yaml` в `flutter.assets` нет `assets/wordlists/` — при восстановлении/генерации мнемоники будет ошибка загрузки.

5. **Сервер: env.example без S3** — `state.rs` требует `S3_ENDPOINT`, `S3_BUCKET`, `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`. В `env.example` их нет — локальный запуск без S3 падает.

---

## Сервер: API и бизнес-логика

6. **Сессии: IP не сохраняется** — при логине в `user_sessions` пишется только `user_agent`, поле `ip` не заполняется. Нужно извлекать IP (ConnectInfo или X-Forwarded-For/X-Real-IP) и передавать в INSERT.

7. **Кик сессии не отзывает доступ** — `kick_session` только удаляет запись из БД. JWT и WebSocket у «кикнутого» устройства остаются валидными до истечения токена. Нужен blacklist JWT/jti в Redis или короткий TTL + проверка сессии при запросах.

8. **В sessions/handlers есть TODO** — комментарий «TODO: Send WebSocket event to client to force logout» не реализован.

9. **Поиск пользователей без авторизации** — `GET /users/search` не требует Authorization. Любой может искать по строке — решить, оставлять ли публичный поиск или требовать JWT.

10. **mark_as_read не проверяет участника чата** — любой авторизованный пользователь может отметить любое сообщение прочитанным; нет проверки, что сообщение из чата, где он участник.

11. **view_message не проверяет участника** — аналогично, можно инкрементировать view_count для чужого чата.

12. **get_messages: has_more считается по len == limit** — при ровно limit сообщениях возвращается has_more: true; корректнее сравнивать с количеством полученных строк.

13. **forward_message: нет лимита на to_chat_ids** — клиент может отправить огромный список чатов; нет cap (например, 10–20).

14. **Редактирование сообщения: жёстко 48 часов** — на бэкенде зашито 48 часов; нет конфигурации и нет проверки политики чата (канал может запрещать правки).

15. **Secret chat: сообщения только в Redis** — при падении Redis или истечении TTL сообщения теряются; нет персистентного хранилища или предупреждения в документации.

16. **Нет пагинации для list_sessions** — при большом числе сессий всё отдаётся одним запросом.

17. **Нет пагинации для list_blocked** — то же для списка заблокированных.

18. **reports: нет лимита на размер decrypted_content** — возможна отправка огромного текста; нужен лимит (например, 64 KB).

19. **Rate limit только на auth** — остальные эндпоинты не ограничены (спам сообщений, поиск, репорты).

20. **JWT: нет jti/revocation** — отзыв токена до истечения срока невозможен без blacklist.

21. **CORS: allow_origin(Any)** — в проде нужно ограничить список origin.

22. **TURN_SECRET в env.example** — значение `change_me_turn_secret` опасно для продакшена; в примере должно быть указание задать свой секрет.

23. **JWT_SECRET в env.example** — `change_me_super_secret` то же; без смены секрета прода уязвим.

24. **Governor key для rate limit** — используется DefaultKeyedStateStore; ключ по умолчанию может быть по IP; за прокси все запросы с одного IP — нужна документация или ключ по заголовку/X-Forwarded-For.

25. **Нет проверки Content-Type на критичных эндпоинтах** — например, POST /api/v1/messages принимает тело без явной проверки application/json.

---

## Сервер: БД и миграции

26. **Миграция 0002 и 0002a** — есть `0002_add_pinned_messages.sql` и `0002a_add_signing_public_key.sql`; порядок применения зависит от алфавита (0002a после 0002). Убедиться, что схема в БД согласована с кодом (signing_public_key, auth_method и т.д.).

27. **reports.reporter_id ON DELETE SET NULL** — при удалении пользователя reporter_id обнуляется; для аудита часто нужно сохранять (или soft delete).

28. **user_sessions: нет индекса по last_used_at** — запросы «последние сессии» могут быть тяжёлыми при большом числе записей.

29. **Нет миграции для таблицы files** — в media/handlers используется таблица `files`; если она создаётся вручную или в другой миграции, в репозитории должна быть явная миграция.

30. **message_hides: уникальность** — если нет UNIQUE(message_id, user_id), возможны дубликаты при повторных «удалить у меня».

---

## Клиент: API и данные

31. **Channel: «Пожаловаться» не вызывает API** — в `channel_screen.dart` по нажатию показывается только SnackBar «Жалоба отправлена»; нет вызова `UserApi().report(...)`.

32. **Чат: нет «Пожаловаться» на сообщение** — нет контекстного меню/кнопки для жалобы на сообщение с отправкой message_id и decrypted_content.

33. **Profile report: decrypted_content — строка, не расшифровка** — для жалобы на пользователя отправляется сформированный текст; для жалобы на сообщение нужно расшифровать payload на клиенте и отправить — этого потока нет в чате.

34. **ChatStore: отправляются только text-сообщения** — TODO «Обработка других типов сообщений»; image/voice/file не уходят на сервер в _sendMessageToServer.

35. **ChatStore: editMessage дважды вызывает edit на сервере** — один раз в try и второй раз внизу в if (message.isMe) MessageApi().editMessage(...).catchError — дублирование запроса.

36. **ChatStore: deleteMessage не проверяет mode** — всегда вызывается mode: 'all'; для «удалить у меня» нужен mode: 'me' и отдельная логика на клиенте (hide локально).

37. **MessageApi.sendMessage: expires_at в ISO8601** — сервер может ожидать другой формат (например, с timezone); проверить контракт.

38. **DioApiClient: Bearer только для /api/v1/ и /calls/** — эндпоинты вроде /users/me (PUT) требуют авторизации; путь в options может быть без ведущего слэша при baseUrl — проверить, что /users/me получает Bearer.

39. **user_api: getProfile без токена** — GET /users/{id} публичный; для приватных полей (если появятся) нужен другой эндпоинт.

40. **listBlocked: ответ сервера — поле blocked_at** — сервер возвращает blocked_at, клиент маппит в Map; UI экрана «Чёрный список» нигде не найден — listBlocked вызывается?

41. **ApiService использует X-PrID** — часть запросов идёт через ApiService с X-PrID; другие через Dio с Bearer. Смешение двух способов идентификации; единообразие лучше.

42. **auth_service: register — пустые signed_prekey и one_time_prekeys** — TODO «Generate proper prekey»; регистрация с пустыми ключами может ломать E2EE для этого пользователя.

43. **ServerConfig.init() вызывается после UserService.init()** — в main.dart порядок: SettingsService, UserService, ..., ServerConfig.init(). Если какой-то код до init() обращается к getApiBaseUrl(), вернётся null/_cachedServerUrl и дефолт.

44. **ServerConfig: fileServer, mediaServer и т.д. — константы** — не берутся из SharedPreferences; смена «сервера» в dev режиме меняет только _defaultMessageServer, остальные остаются старыми.

---

## Клиент: UI и навигация

45. **auth_method_screen: переход на legacy** — `pushNamed('/auth/legacy')`; в routes.dart константа — `AppRoutes.authLegacy`; лучше использовать константу, чтобы не разъехались пути.

46. **Chat: pinnedMessageId из API не подтягивается** — TODO «Получать pinnedMessageId из API»; закреплённое сообщение может не совпадать с сервером.

47. **Chat: открепление** — TODO «Вызвать API для открепления»; кнопка открепления может не вызывать DELETE pin.

48. **Chat: mute/unmute** — TODO «вызов API mute/unmute»; не реализовано.

49. **channel_screen: report** — chatId: null в вызове (TODO получить chatId канала); даже если добавить report(), нужен chatId.

50. **devices_screen: нет признака «текущее устройство»** — список сессий не помечает текущую; сервер не возвращает session_id при логине, клиент не может сопоставить.

51. **settings_hub: «Скрыть время последнего посещения»** — переключатель сохраняется в SettingsService; на сервер (show_online или отдельная настройка) не синхронизируется, только show_online через setShowOnline. Уточнить, что именно скрывать: last_seen или только онлайн.

52. **Нет экрана «Чёрный список»** — listBlocked есть в UserApi, но отдельного экрана со списком заблокированных и кнопкой «Разблокировать» нет; только блок/разблок из профиля.

53. **Profile: кнопки блок/разблок** — после блокировки нужна синхронизация с ChatStore (_blockedContacts) и, при необходимости, с серверным списком; проверить, что разблокировка обновляет UI и список чатов.

54. **Навигация по deep link /join** — маршрут joinByLink есть; обработка ссылки t.mimu.app/join/{token} при холодном старте может требовать проверки.

---

## Клиент: конфигурация и окружение

55. **ServerConfig: захардкоженный IP** — _defaultMessageServer = 'http://10.147.17.50:8080' и остальные серверы; для прода нужен конфигурируемый URL (env, build flavour, remote config).

56. **getApiBaseUrl синхронный** — при первом вызове до init() _cachedServerUrl == null, вернётся дефолт; если init() не вызван, возможны запросы на неинициализированный URL.

57. **getFileUploadUrl и др. не используют сохранённый сервер** — возвращают константы на базе fileServer/mediaServer; при смене «сервера» в настройках файловые URL не меняются.

58. **inviteLinkBase = https://t.mimu.app/join** — константа; если домен сменится, нужно менять в коде или вынести в конфиг.

---

## Клиент: код и качество

59. **Дубликаты кода: lib/Новая папка/** — копии файлов из lib (api_service, auth_screen, settings_hub, server_config и т.д.); путаница и риск расхождений; удалить или чётко обозначить как legacy/бэкап.

60. **api_service: логирование ответов** — в _handleResponse раньше был безусловный print тела/заголовков; в текущей версии обёрнуто в kDebugMode — хорошо; проверить, что нигде не осталось print в проде.

61. **Много print/debugPrint по коду** — 62 вхождения в lib; часть в catch/ошибках — норм; часть может лить чувствительные данные; ревизия и замена на логгер с уровнями желательна.

62. **ErrorHandler: Sentry не подключён** — TODO «Отправка в Sentry/Firebase Crashlytics»; ошибки только в debugPrint.

63. **AnalyticsService: DSN placeholder** — TODO «Добавить реальный DSN»; Sentry инициализируется заглушкой.

64. **MessageQueue: TODO уведомить о неудачной отправке** — при провале отправки из очереди пользователь не получает явного уведомления.

65. **MessageQueue: persist в SharedPreferences/Hive** — TODO; очередь при перезапуске может теряться.

66. **NotificationService: TODO NavigationService** — при нажатии на пуш навигация не интегрирована.

67. **dev_mode_screen: «Статистика сети»** — TODO; кнопка показывает SnackBar «TODO».

68. **dev_mode_screen: «Сбросить сессию»** — TODO; не реализовано.

69. **Validators.sanitizeText** — экранирует HTML; если текст потом рендерится как HTML (например, в WebView или markdown с HTML), возможны двойные экранирования или обход; единый слой рендеринга и санитизации задать явно.

70. **Validators: validateMessage 4096 символов** — сервер может не проверять длину encrypted_payload; при большом сообщении ошибка может прийти только с бэкенда.

71. **LocalStorage: нет миграции схемы Hive** — при изменении полей ChatMessage/ChatThread старые боксы могут не читаться; нужна стратегия миграции или версионирование.

72. **ChatStore: _seedDemoChats при пустых данных** — при первом запуске без сервера показываются демо-чаты; при продакшене лучше пустой список или онбординг.

73. **ChatStore: синхронизация блоков с сервером** — _blockedContacts грузятся из SharedPreferences; при блоке через профиль обновляется ли сервер и локальный список — проверить двустороннюю синхронизацию.

74. **SettingsService: setHideLastSeenTime** — сохраняется только локально; если на бэкенде есть настройка «скрыть last_seen», её нужно синхронизировать (например, через updateMe(settings: {...})).

75. **Theme/accents** — тема и шрифты хранятся в SharedPreferences; при смене устройства нет синхронизации с сервером (если не планируется — ок).

---

## Безопасность и приватность

76. **JWT в памяти/SharedPreferences** — токен хранится в plaintext; на рутированном устройстве возможна кража; для высоких требований — защищённое хранилище (flutter_secure_storage).

77. **Refresh token: только в памяти/префах** — то же; при логауте нужно явно удалять и, при возможности, отзывать на сервере (если появится revocation).

78. **Мнемоника/сид** — если хранятся на устройстве, должны быть в защищённом хранилище; проверить crypto_auth_service и recovery_phrase экраны.

79. **Логи: не логировать токены и расшифрованный контент** — при добавлении логгера убедиться, что в логи не попадают Bearer, refresh, decrypted_content.

80. **Сервер: логирование ошибок БД** — в части мест только `map_err(|_| ApiError::internal("db error"))`; для отладки полезно логировать причину (с учётом того, чтобы не светить данные в прод).

81. **CORS и заголовки** — X-Content-Type-Options, X-Frame-Options, Referrer-Policy заданы; Content-Security-Policy не настроена (если будет веб-клиент — пригодится).

82. **Регистрация: нет капчи** — эндпоинт регистрации ограничен по rate, но нет капчи; боты могут перебирать public_id.

83. **Пароль: политика сложности** — validate_password на сервере проверяет длину и т.п.; убедиться, что политика достаточна и единообразна с клиентом.

---

## Производительность и масштаб

84. **WebSocket: все соединения в памяти (DashMap)** — при нескольких инстансах сервера нужен Redis pub/sub для доставки между инстансами; redis_listener уже есть для ws:user:* — убедиться, что все пути публикации сообщений пишут в Redis.

85. **get_messages: лимит 100** — жёсткий cap 100; при очень длинных чатах пагинация есть, но размер страницы не конфигурируется.

86. **Список чатов на клиенте** — загрузка всех чатов в память; при большом числе чатов нужна пагинация или ленивая подгрузка.

87. **Hive: все чаты/сообщения в памяти при init** — ChatStore.init загружает все чаты и сообщения из LocalStorage; при росте данных возможны тормоза и OOM.

88. **Нет индикации «идёт загрузка» при первой открытии чата** — если сообщения подгружаются с сервера, пользователю может быть неочевидно, что идёт запрос.

89. **Изображения: сжатие в MediaProcessor** — при загрузке изображения сжимаются; параметры (качество, размер) захардкожены; для консистентности с серверными лимитами проверить.

90. **Сервер: размер encrypted_payload** — нет явного лимита на размер тела сообщения; большая вставка может нагрузить БД и сеть.

---

## Тесты и документация

91. **Сервер: тесты только calls** — в tests/ в основном integration_calls; нет интеграционных тестов для auth, messages, chats, report, sessions.

92. **Клиент: тесты** — в test/ один файл; критичные потоки (auth, отправка сообщения, блок) не покрыты.

93. **API контракт не описан** — нет OpenAPI/Swagger; при смене форматов легко сломать клиент.

94. **Миграции: порядок и откат** — нет описания, как откатывать миграции при необходимости; в продакшене это риск.

95. **README и env.example** — в env.example нет S3, JWT_EXPIRATION_HOURS, опциональных переменных; новый разработчик может не поднять окружение.

96. **Дублирование документации** — много .md в корне (RELEASE_NOTES, IMPLEMENTATION_*, PRODUCTION_*, SERVER_OVERVIEW и т.д.); привести к одному актуальному обзору и ссылкам.

---

## Мелкие и косметические

97. **Роут /auth/legacy** — в коде используется строка '/auth/legacy'; в routes — AppRoutes.authLegacy = '/auth/legacy'; дублирование; везде использовать константу.

98. **Опечатки и разночтения** — «Пожаловаться» / «Жалоба отправлена» в разных экранах; «Сессия завершена» / «Устройство будет отключено» — проверить единый тон.

99. **Пустые/заглушки строки** — например, fingerprint: '' при регистрации с комментарием «Will be computed server-side»; сервер пересчитывает — ок, но на клиенте можно сразу передавать вычисленный.

100. **Версия клиента** — X-Client-Version: 1.0.0 в ApiService; при релизах нужно поднимать и, при необходимости, проверять на сервере для совместимости.

---

## Сводка по приоритетам

- **Сделать в первую очередь:** 1 (forbidden), 2 (baseUrl), 3 (crypto routes), 4 (wordlists), 5 (env S3).
- **Важно для релиза:** 6–8 (сессии, кик), 31–33 (жалобы), 41–43 (auth/prekeys), 55–57 (конфиг).
- **Желательно:** остальные по категориям (безопасность, тесты, производительность, документация).

Если нужно, могу предложить конкретные патчи по пунктам 1–5 и любому блоку из списка.
